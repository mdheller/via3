/* Javascript interceptions for rewriting HTML pages */

// nb. Content is wrapped in an IIFE to prevent variables from becoming
// visible to rest of page. If we change this script to be generated by a
// bundler we won't need to do this.

(function() {
  class URLRewriter {
    // Partial port of via3.services.rewriter.url.URLRewriter

    constructor(settings) {
      this.baseUrl = settings.baseUrl;
      this.baseScheme = this._urlScheme(this.baseUrl);
      this.urlTemplates = settings.urlTemplates;
    }

    _urlScheme(url) {
      if (url.startsWith("https:")) {
        return "https";
      } else if (url.startsWith("http:")) {
        return "http";
      }
      return null;
    }

    makeAbsolute(url) {
      if (url.startsWith("//")) {
        return this.baseScheme + ":" + url;
      }

      return new URL(url, this.baseUrl).toString();
    }

    canProxy(url) {
      return url.startsWith("https:") || url.startsWith("http:");
    }

    proxyStatic(url) {
      // We don't URL escape the paths that go direct through NGINX
      return this._templateRewrite(url, this.urlTemplates.PROXY_STATIC, false);
    }

    rewriteJS(url) {
      return this._templateRewrite(url, this.urlTemplates.REWRITE_JS);
    }

    rewriteHTML(url) {
      return this._templateRewrite(url, this.urlTemplates.REWRITE_HTML);
    }

    rewriteCSS(url) {
      return this._templateRewrite(url, this.urlTemplates.REWRITE_CSS);
    }

    _templateRewrite(url, template, encode = true) {
      console.log("Rewrite incoming URL", url);

      let absoluteUrl = this.makeAbsolute(url);
      console.log("  > (absolute)", url);

      if (!this.canProxy(absoluteUrl)) {
        console.log("  > (can't proxy)");
        return absoluteUrl;
      }

      if (encode) {
        absoluteUrl = encodeURIComponent(absoluteUrl);
        console.log("  > (encoded)", absoluteUrl);
      }

      const finalUrl = template.replace("__URL__", absoluteUrl);
      console.log("  > (final)", finalUrl);

      return finalUrl;
    }
  }

  function patchXHRAndFetch(urlRewriter) {
    console.log("Initializing Via DOM API monkey-patching");

    const origFetch = window.fetch;
    window.fetch = (url, ...args) => {
      console.log("Via: Triggered fetch patch", url, args);
      return origFetch.call(null, urlRewriter.proxyStatic(url), ...args);
    };

    const origOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url, ...args) {
      console.log("Via: Triggered XMLHttpRequest patch", method, url, args);
      return origOpen.call(this, method, urlRewriter.proxyStatic(url), ...args);
    };
  }

  function patchHistory(urlRewriter) {
    const origReplaceState = history.replaceState;
    history.replaceState = function(state, title, url) {
      console.log("Via: Tried to replace history", state, title, url);
      origReplaceState.call(
        history,
        state,
        title,
        urlRewriter.rewriteHTML(url)
      );
      //return pushState.apply(history, arguments);
    };
    const origPushState = history.pushState;
    history.pushState = function(state, title, url) {
      console.log("Via: Tried to change history", state, title, url);
      origPushState.call(history, state, title, urlRewriter.rewriteHTML(url));
      //return pushState.apply(history, arguments);
    };
  }

  function patchServiceWorker(urlRewriter) {
    // Pretend to be an old browser that doesn't support ServiceWorker.
    delete Object.getPrototypeOf(navigator).serviceWorker;
  }

  /**
   * A replacement for the `Location` object returned by `window.location`
   * which behaves as if the location is the proxied URL rather than the
   * actual URL (which includes Via).
   *
   * This implements the `Location` API described at
   * https://developer.mozilla.org/en-US/docs/Web/API/Location
   */
  class ViaLocation {
    /**
     * @param {Location} location - The real `location` object
     * @param {string} proxiedURL - The URL being viewed through the proxy
     * @param {(url: string) => string} rewriteURL -
     *    Function that rewrites a URL so that it is delivered through the
     *    proxy.
     */
    constructor(location, proxiedURL, rewriteURL) {
      this._location = location;
      this._proxiedURL = new URL(proxiedURL);
      this._rewriteURL = rewriteURL;
    }

    get ancestorOrigins() {
      return [this._proxiedURL.origin];
    }

    get href() {
      return this._proxiedURL.href;
    }

    set href(value) {
      this._location.href = this._rewriteURL(value);
    }

    get protocol() {
      return this._proxiedURL.protocol;
    }

    set protocol(value) {
      this._setPart("protocol", value);
    }

    get host() {
      return this._proxiedURL.host;
    }

    set host(value) {
      this._setPart("host", value);
    }

    get hostname() {
      return this._proxiedURL.hostname;
    }

    set hostname(value) {
      this._setPart("hostname", value);
    }

    get port() {
      return this._proxiedURL.port;
    }

    set port(value) {
      this._setPart("port", value);
    }

    get pathname() {
      return this._proxiedURL.pathname;
    }

    set pathname(value) {
      this._setPart("pathname", value);
    }

    get search() {
      return this._proxiedURL.search;
    }

    set search(value) {
      this._setPart("search", value);
    }

    get hash() {
      return this._proxiedURL.hash;
    }

    set hash(value) {
      this._setPart("hash", value);
    }

    get origin() {
      return this._proxiedURL.origin;
    }

    assign(url) {
      this._location.assign(this._rewriteURL(url));
    }

    reload() {
      this._location.reload();
    }

    replace(url) {
      this._location.replace(this._rewriteURL(url));
    }

    toString() {
      return this._proxiedURL.href;
    }

    _setPart(part, value) {
      this._proxiedURL[part] = value;
      this._location.href = this._rewriteURL(this._proxiedURL.href);
    }
  }

  function patchLocation(urlRewriter, baseUrl) {
    const viaLocation = new ViaLocation(location, baseUrl, url =>
      urlRewriter.rewriteHTML(url)
    );

    const viaLocationDescriptor = {
      enumerable: true,
      configurable: true,

      get(value) {
        return viaLocation;
      },

      set(value) {
        viaLocation.href = value;
      }
    };

    // Create a location property that refers to the proxied URL.
    // `document.location` and `window.location` are "unforgeable" so instead of
    // monkey-patching the original property we instead use server-side rewriting
    // to replace references to `location` with `viaLocation` and then install the
    // `viaLocation` property here.
    Object.defineProperty(document, "viaLocation", viaLocationDescriptor);
    Object.defineProperty(window, "viaLocation", viaLocationDescriptor);
  }

  const urlRewriter = new URLRewriter(VIA_REWRITER_SETTINGS);
  patchXHRAndFetch(urlRewriter);
  patchHistory(urlRewriter);
  patchServiceWorker(urlRewriter);
  patchLocation(urlRewriter, VIA_REWRITER_SETTINGS.baseUrl);
})();
